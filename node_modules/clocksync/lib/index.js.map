{"version":3,"sources":["../src/index.js"],"names":["ClockSync","sendRequest","syncCallback","interval","delay","repeat","now","TypeError","_syncing","_sync_id","_timeout_id","_results","_offset","_sync_complete","_time_of_sync","_cancel_request","_perform_nasty_side_effects","new_result","results","slice","length","shift","push","roundtrips","map","result","roundtrip","roundtrip_limit","filtered","filter","offsets","offset","has_new_offset","_now","_sync","sync_start_time","err","server_timestamp","Error","sync_end_time","setTimeout","start","time_since_last_sync","stop","clearTimeout","isSyncing"],"mappings":"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","file":"index.js","sourcesContent":["import { median, std, mean } from './stat'\nimport { SYNC_CALLBACK, INTERVAL, DELAY, REPEAT, NOW } from './defaults'\n\n/**\n * Let's synchronize our clocks!  ClockSync will continuously keep a client's clock\n *  synchronized with the server's clock.\n *\n * @param sendRequest - \n */\nexport default function ClockSync({\n\tsendRequest,\n\tsyncCallback = SYNC_CALLBACK,\n\tinterval = INTERVAL,\n\tdelay = DELAY,\n\trepeat = REPEAT,\n\tnow = NOW\n} = {}) {\n\tif( typeof sendRequest !== 'function') {\n\t\tthrow new TypeError(`ClockSync: expected sendRequest to be a function but was ${typeof sendRequest}`);\n\t}\n\tif( typeof syncCallback !== 'function' ) {\n\t\tthrow new TypeError(`ClockSync: expected syncCallback to be a function but was ${typeof syncCallback}`);\n\t}\n\tif( typeof interval !== 'number' && interval >= 0\t) {\n\t\tthrow new TypeError('ClockSync: interval must be a positive number');\n\t}\n\tif( typeof delay !== 'number' && delay <= interval) {\n\t\tthrow new TypeError('ClockSync: delay must be a positive number no greater than interval');\n\t}\n\tif( typeof repeat !== 'number' && repeat >= 1 ) {\n\t\tthrow new TypeError('ClockSync: repeat must be a postitive number no smaller than 1');\n\t}\n\tif( typeof now !== 'function' ) {\n\t\tthrow new TypeError('ClockSync: now must be a function');\n\t}\n\n\tlet _syncing = false;\n\tlet _sync_id = -1;\n\tlet _timeout_id = null;\n\tlet _results = [];\n\tlet _offset = 0;\n\tlet _sync_complete = false;\n\tlet _time_of_sync = null;\n\tlet _cancel_request = null;\n\n\t/*\n\t * there's a whole bunch of nasty side effects\n\t */\n\tfunction _perform_nasty_side_effects(new_result) {\n\t\tconst results = _results.slice();\n\t\tif(results.length >= repeat) {\n\t\t\tresults.shift();\n\t\t}\n\t\tresults.push(new_result);\n\t\t// calculate the limit for outliers\n\t\tconst roundtrips = results.map(result => result.roundtrip);\n\t\tconst roundtrip_limit = median(roundtrips) + std(roundtrips);\n\n\t\t// filter all results which have a roundtrip smaller than the mean+std\n\t\tconst filtered = results.filter(result => result.roundtrip < roundtrip_limit);\n\t\tconst offsets = filtered.map(result => result.offset);\n\n\t\tconst has_new_offset = offsets.length > 0;\n\n\t\t_sync_id += 1;\n\n\t\t_offset = has_new_offset \n\t\t\t? mean(offsets) \n\t\t\t: _offset;\n\n\t\t_sync_complete = results.length >= repeat;\n\t\tif(has_new_offset) {\n\t\t\t_time_of_sync = _now();\n\t\t}\n\t\t_results = results;\n\n\t\treturn has_new_offset;\n\t}\n\n\tfunction _sync() {\n\t\t_timeout_id = null;\n\t\tif( !_syncing ) return;\n\t\tif(_sync_complete) {\n\t\t\t_results = [];\n\t\t\t_sync_complete = false;\n\t\t}\n\t\tlet has_new_offset = false;\n\t\ttry {\n\t\t\tconst sync_start_time = now();\n\t\t\t_cancel_request = sendRequest( _sync_id, (err, server_timestamp) => {\n\t\t\t\t_cancel_request = null;\n\t\t\t\tif( !_syncing ) return;\n\t\t\t\tif(err) {\n\t\t\t\t\tsyncCallback(err);\n\t\t\t\t}\n\t\t\t\tif( server_timestamp <= 0 ) {\n\t\t\t\t\tsyncCallback( new Error(`ClockSync: the timestamp from the server must be a postiive number (${server_timestamp})`) );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tconst sync_end_time = now();\n\t\t\t\t\tconst roundtrip = sync_end_time - sync_start_time;\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\troundtrip: roundtrip,\n\t\t\t\t\t\toffset: server_timestamp - sync_end_time + roundtrip / 2\n\t\t\t\t\t};\n\t\t\t\t\thas_new_offset = _perform_nasty_side_effects(result);\n\t\t\t\t\t_timeout_id = setTimeout(_sync, _sync_complete ? interval : delay);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsyncCallback(err);\n\t\t\t\t}\n\t\t\t\tif( has_new_offset ) {\n\t\t\t\t\tsyncCallback(null, _offset, _sync_complete);\n\t\t\t\t}\n\t\t\t} )\n\t\t} catch (err) {\n\t\t\tsyncCallback(err);\n\t\t}\n\t}\n\n\tfunction _now() {\n\t\treturn now() + _offset;\n\t}\n\n\treturn {\n\t\tstart() {\n\t\t\tif(_syncing) {\n\t\t\t\tthrow new Error('ClockSync: cannot call ClockSync.start() on an already synchronizing clock.');\n\t\t\t}\n\t\t\t_syncing = true;\n\t\t\tif( _sync_complete ) {\n\t\t\t\tconst time_since_last_sync = _now() - _time_of_sync;\n\t\t\t\t// if more time has elapsed since we last synchronized\n\t\t\t\t//  then lets sync right now\n\t\t\t\tif( interval > time_since_last_sync ) {\n\t\t\t\t\t_timeout_id = setTimeout(_sync, 0);\n\t\t\t\t} else {\n\t\t\t\t\t_timeout_id = setTimeout(_sync, interval - time_since_last_sync);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// sync right now\n\t\t\t\t_timeout_id = setTimeout(_sync, 0);\n\t\t\t}\n\t\t},\n\t\tstop() {\n\t\t\tif(!_syncing) {\n\t\t\t\tthrow new Error('ClockSync: cannot call ClockSync.stop() on an clock that is not synchronizing.');\n\t\t\t}\n\t\t\tif(_cancel_request) {\n\t\t\t\t_cancel_request();\n\t\t\t}\n\t\t\t_syncing = false;\n\t\t\tclearTimeout(_timeout_id);\n\t\t},\n\t\tnow: _now,\n\t\tget offset() {\n\t\t\treturn _offset;\n\t\t},\n\t\tget isSyncing() {\n\t\t\treturn _syncing;\n\t\t},\n\t};\n};\n\n"]}