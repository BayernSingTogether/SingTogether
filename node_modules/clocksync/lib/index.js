'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.default = ClockSync;

var _stat = require('./stat');

var _defaults = require('./defaults');

/**
 * Let's synchronize our clocks!  ClockSync will continuously keep a client's clock
 *  synchronized with the server's clock.
 *
 * @param sendRequest - 
 */
function ClockSync() {
	var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	var sendRequest = _ref.sendRequest;
	var _ref$syncCallback = _ref.syncCallback;
	var syncCallback = _ref$syncCallback === undefined ? _defaults.SYNC_CALLBACK : _ref$syncCallback;
	var _ref$interval = _ref.interval;
	var interval = _ref$interval === undefined ? _defaults.INTERVAL : _ref$interval;
	var _ref$delay = _ref.delay;
	var delay = _ref$delay === undefined ? _defaults.DELAY : _ref$delay;
	var _ref$repeat = _ref.repeat;
	var repeat = _ref$repeat === undefined ? _defaults.REPEAT : _ref$repeat;
	var _ref$now = _ref.now;
	var now = _ref$now === undefined ? _defaults.NOW : _ref$now;

	if (typeof sendRequest !== 'function') {
		throw new TypeError('ClockSync: expected sendRequest to be a function but was ' + (typeof sendRequest === 'undefined' ? 'undefined' : _typeof(sendRequest)));
	}
	if (typeof syncCallback !== 'function') {
		throw new TypeError('ClockSync: expected syncCallback to be a function but was ' + (typeof syncCallback === 'undefined' ? 'undefined' : _typeof(syncCallback)));
	}
	if (typeof interval !== 'number' && interval >= 0) {
		throw new TypeError('ClockSync: interval must be a positive number');
	}
	if (typeof delay !== 'number' && delay <= interval) {
		throw new TypeError('ClockSync: delay must be a positive number no greater than interval');
	}
	if (typeof repeat !== 'number' && repeat >= 1) {
		throw new TypeError('ClockSync: repeat must be a postitive number no smaller than 1');
	}
	if (typeof now !== 'function') {
		throw new TypeError('ClockSync: now must be a function');
	}

	var _syncing = false;
	var _sync_id = -1;
	var _timeout_id = null;
	var _results = [];
	var _offset = 0;
	var _sync_complete = false;
	var _time_of_sync = null;
	var _cancel_request = null;

	/*
  * there's a whole bunch of nasty side effects
  */
	function _perform_nasty_side_effects(new_result) {
		var results = _results.slice();
		if (results.length >= repeat) {
			results.shift();
		}
		results.push(new_result);
		// calculate the limit for outliers
		var roundtrips = results.map(function (result) {
			return result.roundtrip;
		});
		var roundtrip_limit = (0, _stat.median)(roundtrips) + (0, _stat.std)(roundtrips);

		// filter all results which have a roundtrip smaller than the mean+std
		var filtered = results.filter(function (result) {
			return result.roundtrip < roundtrip_limit;
		});
		var offsets = filtered.map(function (result) {
			return result.offset;
		});

		var has_new_offset = offsets.length > 0;

		_sync_id += 1;

		_offset = has_new_offset ? (0, _stat.mean)(offsets) : _offset;

		_sync_complete = results.length >= repeat;
		if (has_new_offset) {
			_time_of_sync = _now();
		}
		_results = results;

		return has_new_offset;
	}

	function _sync() {
		_timeout_id = null;
		if (!_syncing) return;
		if (_sync_complete) {
			_results = [];
			_sync_complete = false;
		}
		var has_new_offset = false;
		try {
			(function () {
				var sync_start_time = now();
				_cancel_request = sendRequest(_sync_id, function (err, server_timestamp) {
					_cancel_request = null;
					if (!_syncing) return;
					if (err) {
						syncCallback(err);
					}
					if (server_timestamp <= 0) {
						syncCallback(new Error('ClockSync: the timestamp from the server must be a postiive number (' + server_timestamp + ')'));
					}
					try {
						var sync_end_time = now();
						var roundtrip = sync_end_time - sync_start_time;
						var result = {
							roundtrip: roundtrip,
							offset: server_timestamp - sync_end_time + roundtrip / 2
						};
						has_new_offset = _perform_nasty_side_effects(result);
						_timeout_id = setTimeout(_sync, _sync_complete ? interval : delay);
					} catch (err) {
						syncCallback(err);
					}
					if (has_new_offset) {
						syncCallback(null, _offset, _sync_complete);
					}
				});
			})();
		} catch (err) {
			syncCallback(err);
		}
	}

	function _now() {
		return now() + _offset;
	}

	return {
		start: function start() {
			if (_syncing) {
				throw new Error('ClockSync: cannot call ClockSync.start() on an already synchronizing clock.');
			}
			_syncing = true;
			if (_sync_complete) {
				var time_since_last_sync = _now() - _time_of_sync;
				// if more time has elapsed since we last synchronized
				//  then lets sync right now
				if (interval > time_since_last_sync) {
					_timeout_id = setTimeout(_sync, 0);
				} else {
					_timeout_id = setTimeout(_sync, interval - time_since_last_sync);
				}
			} else {
				// sync right now
				_timeout_id = setTimeout(_sync, 0);
			}
		},
		stop: function stop() {
			if (!_syncing) {
				throw new Error('ClockSync: cannot call ClockSync.stop() on an clock that is not synchronizing.');
			}
			if (_cancel_request) {
				_cancel_request();
			}
			_syncing = false;
			clearTimeout(_timeout_id);
		},

		now: _now,
		get offset() {
			return _offset;
		},
		get isSyncing() {
			return _syncing;
		}
	};
};
//# sourceMappingURL=index.js.map